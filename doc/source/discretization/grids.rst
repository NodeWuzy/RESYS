
---------------------------------------
方程离散的网格的划分
---------------------------------------

在程序从输入文件中读取完所有的输入之后，程序开始建立控制体，并且划分网格。
在RESYS程序中，建立起用于方程网格离散的数据主要包括三个步骤。
首先RESYS程序会对输入的部件进行回路的划分，将不同的部件并归到不同的回路。
将不同的部件并归到不同的回路的目的是对不同的回路单独求解，对没有水力学连接的回路进行解耦，提高计算速度。

其次需要从输入文件中建立起关于控制体的数据，包括控制体的长度、水力直径、体积、表面粗超度、以及体积中心等信息。
然后需要建立起控制体的连接数据，也就是所谓的接管的信息，包括接管的面积、接管连接的控制体的编号等信息。
这些信息会用于方程的建立。

这一节的主要内容是讨论方程离散的网格划分。

回路的划分
----------------------

在RESYS程序中，回路划分的目的是将每个的回路的控制体和接管的数据集中到一起。
这样便于对每个回路单独求解，减小所需要的计算量，以及可以对每个回路单独使用特殊模型等优点。
:class:`回路` 定义为通过接管相互相连的控制体和定义在这些控制体上的特殊模型的集合。
不同的回路之间的控制体永远不会通过接管相连。
在实际的应用中，一个典型的例子是压水反应堆的一回路和二回路，在回路完整时，它们之间永远不会相连。
在蒸汽发生器的U型管发生破损时，一回路和二回路之间会存在质量交换。
此时，在RESYS程序中，一、二回路仅仅定义为一个回路(loop)。
在实际的RESYS程序中，一个回路对应于一个 ``loops`` 类的对象，关于回路的所有数据都存储在该对象中。

回路的划分在函数 ``component::resys::create_loops()`` 中完成。

控制体的划分与建立
---------------------

在RESYS程序中，控制体主要包括三类：一类是单一控制体，另一类是分支控制体部件 :class:`volumeBranch` 使用的无流动方向的控制体，另一类是定义边界条件的时间相关控制体。
在读取完成所有的水力学部件以后程序依次建立起这三类控制体的信息。

首先，程序会统计出在每个回路中两类控制体的数目：  

- ``internal volume number`` : 内部控制体数目
- ``time dependent volume number`` : 时间相关控制体的数目

这两类控制体数目的大小会作为程序流场内存分配的依据。内部物理场的定义的内存大小为 :class:`internal volume number`。
边界物理场的定义使用的内存大小为 :class:`boundary volume number` ，其值刚好和时间相关控制体大小一致。
在RESYS程序为变量申请内存时，内部物理场和边界物理场位于同一个数组中，内部物理场位于前面，边界物理场的存储位置在最后面。

总的控制体数目 ``control volume number`` 是这两类控制体的数目之和。

然后，在得到控制体的数目之和，程序对控制体进行排序。
对控制体进行排序的目的是方便接管的连接数据的建立。
对控制体进行排序的依据是根据部件的种类。
首先，管型部件的控制体排在最前面，第一个管型部件入口的第一个控制体的序号为 ``0`` 。
然后单一控制体部件的序号排在所有管型部件控制体的后面。
之后是分支部件的控制体序号，分支控制体部件的序号排在前面管型部件和单一控制体的后面。
最后是分支控制体部件的控制体的序号，它排在前面所有的 ``norm control volume`` 的后面。
然后再最后对系统中的时间相关控制体排序。时间相关控制体排在最后面，由于其是用于定义边界条件的控制体。
**值得指出的是，这些控制体的编号与其物理场的存储顺序刚好一致。**

之后再建立起各个控制体几何信息与控制体的表面粗糙度信息。之后建立各个控制体的几何中心和控制体的方向。
然后就完成了控制体的划分这一步。

这一步与RESYS程序中的 ``resys::component::loops::create_control_volume()`` 函数相对应。
该函数的定义如下：

.. code-block:: c++

		//=======================================
		// 建立系统回路中控制体的信息		
		//=======================================
		void loops::create_control_volume() {

			// 首先要找出的控制体的总数目
			control_volume_number        = control_volume_total_num();
			none_flow_volume_number      = int(volumeBranchs.size());
			time_dependent_volume_number = int(timeDependentVolumes.size());
			norm_control_volume_number   = control_volume_number
				- none_flow_volume_number
				- time_dependent_volume_number;
			internal_control_volume_number = control_volume_number
				- time_dependent_volume_number;
			// 将控制体进行排序编号
			control_volume_numbering();
			// 计算控制体的几何
			control_volume_size_info();
			// 计算控制体的粗超度
			control_volume_roughness();
			// 计算控制体的中心的朝向
			contorl_volume_center_and_orientation();
			// more ......
		}


接管数据的建立
--------------

在完成控制体的建立之后，需要建立回路中接管的连接数据。接管用于连接控制体，因此接管所需要的数据包括接管的面积、接管的形阻压降系数、以及接管连接的控制体。
在RESYS中，接管主要包括了三类，一类是连接单一控制体入口的 ``普通接管`` ，一类是连接单一控制体的入口和侧面的 ``T横流接管`` ，一类是连接单一控制体侧面与侧面的 ``II横流接管``。

由于这三类接管描述不同形式的动量方程，因此RESYS程序会分别建立这三类接管的数据。
在接管数据建立的第一步，程序会统计出系统中这三类接管的数量与接管的总数。
然后程序会统计出这三类所有的接管的流动面积。

建立接管的数据中最复杂以及关键的一步是建立起接管的连接数据，也就是接管连接的控制体的编号。
按照接管在系统划分的网格中的位置可以将接管分为两类，一类是只与内部的控制体相连的内部接管 :class:`internal junction` ，一类是与时间相关控制体相连的边界接管 :class:`boundary junction` 。
时间相关接管既可以是内部接管，也可以是边界接管。内部接管用于系统中内部控制体的相互连接，是内部离散守恒方程时需要的，而边界接管与边界上的控制体相连。
由于边界上的控制体并不在离散的方程系统中，因此边界接管仅用于定义边界条件。

在程序实现中，将内部接管和边界接管分开来存储可以使得在建立控制体的守恒方程时更加高效。
在下一小节中我们可以看到，在建立控制体的方程时，只需要对内部接管循环，在建立控制体守恒方程的边界条件时，只需要对边界接管进行循环。
因此将内部接管和边界接管分开来存储在计算效率上更高。

另一个方面，程序中对边界接管的定义是在输入文件读取完成后由程序自动完成的。
因此在最开始的时候，程序并不知道哪一个接管是连接到时间相关控制体中的，也就不知道哪一个接管是边界接管。
所以程序需要对接管分类，将内部接管分为一组，将边界接管分为一组。
在RESYS对接管进行排序时，会将连接到边界控制体的接管识别边界接管，并将其置于所有的内部接管的后面。

在RESYS程序中，对接管数据的建立在函数 ``resys::component::loops::create_junction()``。
该函数的定义如下：

.. code-block:: c++

		void loops::create_junction() {

			// 建立接管的连接数据
			create_junction_link();
			// 统计接管的数量
			junction_numbers();
			// 对接管进行排序
			junction_numbering();
			// 建立接管两端的控制体编号
			create_junction_owner_and_neigh();
			// 建立接管连接的状态参数
			create_junction_connection_state();
			// 建立接管的面积
			create_junction_area();
			// 建立接管两端的控制体的等效半长度
			create_junction_DLs_and_DRs();
			// 建立连接到每个控制体上的接管的总数
			total_volume_junction_number();
			// 建立接管的形状阻力系数
			create_junction_form_loss_factor();
			// 建立接管突阔突缩模型选项
			abrute_junction_index();
			// 建立接管两端动量方程的
			// 对流项与摩擦阻力项
			create_junction_momentum();
			// 建立边界控制体的信息
			boundary_control_volume();
			// 建立边界接管的信息
			boundary_junction_info();
			// 建立接管两端控制体的空间位置差值
			create_junction_cell_center_diff();
			// 建立接管上的速度方向和控制体
			// 速度方向是否相同信息
			create_junction_velocity_direction();
			// more .......
		}

. 在建立接管数据的第一步，需要建立接管的连接数据，这一步在函数 ``create_junction_link()`` 中进行。
在这一步，程序将从输入文件中读取的连接字符串 :class:`link_string` 解析为连接的控制体的编号，
并将这些编号保存到定义单一接管、分支等部件的 **对象** 中。

- 然后第二步， ``junction_numbers()`` 用以统计各种接管的数目，包括内部接管数和边界接管数等。

- 在第三步，   ``junction_numbering()``  会对所有的接管进行排序，并将排序的结果保存到定义单一接管、分支等部件的 **对象** 中。

- 在第四步， ``create_junction_owner_and_neigh()`` 会建立起接管部件两端的控制体编号。
  在RESYS程序中接管两端连接的控制体分别称为 ``owner`` 和 ``neigh(neighbour)``。
  而接管上的流量大小定义为从  ``owner`` 流向 ``neigh`` 为正，否则为负。

- 在进行完上面步骤后，就可以按照排好的顺序依次产生接管的信息，并将这些信息保存到一个数值中。
  比如建立接管的面积的数组，其每个接管的数据的次序就是按照前面的排序结果产生的。

^^^^^^^^^^^
接管的排序
^^^^^^^^^^^

在求解动量方程时，需要在接管的位置上构建方程组。
这就要求程序需要给接管进行排序以定义 ``junction field`` 的内存存储的物理量对应的接管序号。
具体来说，对RESYS程序，其排序规则可以简要的归纳如下：

首先，所有的与时间相关控制体相连的接管和时间相关接管排在内部接管和内部时间相关接管的后面。
其次，时间相关接管排在普通的接管的后面。
对于普通的接管(除去时间相关接管和边界接管)，其排序的规则是管型部件的内部接管排在最前面，
单一接管部件定义的内部接管排在回路内所有管型部件的接管的后面，之后分别是分支部件和分支控制体部件。

对于边界接管，其排在所有的内部接管的后面，普通的边界接管(非时间相关边界接管)的排序规则和上面类似。
时间相关边界接管排在最后面。




















